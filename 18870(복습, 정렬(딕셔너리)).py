# 18870 좌표 압축

# 문제
# 수직선 위에 N개의 좌표 X1, X2, ..., XN이 있다. 이 좌표에 좌표 압축을 적용하려고 한다.

# Xi를 좌표 압축한 결과 X'i의 값은 Xi > Xj를 만족하는 서로 다른 좌표의 개수와 같아야 한다.

# X1, X2, ..., XN에 좌표 압축을 적용한 결과 X'1, X'2, ..., X'N를 출력해보자.

# 입력
# 첫째 줄에 N이 주어진다.

# 둘째 줄에는 공백 한 칸으로 구분된 X1, X2, ..., XN이 주어진다.

# 출력
# 첫째 줄에 X'1, X'2, ..., X'N을 공백 한 칸으로 구분해서 출력한다.

import sys
input = sys.stdin.readline

n = int(input())
dic = {}

nums = list(map(int, input().split()))
sNums = sorted(set(nums)) # 중복 제거

for i in range(len(sNums)):
    dic[sNums[i]] = i

for j in nums:
    print(dic[j], end=' ')



# 문제를 간단하게 설명하자면 좌표를 크기 순으로 0부터 나열하여 같은 좌표는 같은 수를 출력하도록 하는 문제이다.

# 예를 들면 (5, 6, 7, 8, 5) 를 입력받으면 크기대로 (0, 1, 2, 3, 0)을 출력하면 된다.

# 풀이
# 이 문제에서 주의하여야 할 점은 중복되는 수가 있다면 같은 수를 줘야 하지만 단순히 sort만을 이용하면 중복 순위로 인해 값이 커지게 된다. 그러므로 set을 이용해 중복 값을 없애는 작업이 필요하다.

# 순위를 어떠한 방식으로 매길지 고민을 하다 딕셔너리를 이용하여 풀이한 방법이 제일 좋다고 생각했다. (딕셔너리의 특성에 대해서는 따로 정리하였습니다.) - 딕셔너리 자료형(Dictionary) - Python

# 딕셔너리의 키값을 순위로 이용하여 딕셔너리(dic)에 0부터 추가하는 for문을 작성하였고 다시 원래의 좌표들(nums)를 도는 for문으로 value값을 입력하면 키값을 반환하는 딕셔너리의 특성을 이용하여 문제를 풀이했다.